
struct OBJ_COTHREAD
{
    COTHREAD_ID,
    COTHREAD_STACK_SEG,
    COTHREAD_STACK_OFF,
    COTHREAD_NEXT,
    COTHREAD_IPC_DONE,
    COTHREAD_IPC_VALUE,
    COTHREAD_IPC_SEG,
    COTHREAD_IPC_OFF
}

const MAX_COTHREADS = 128;

auto _cothreads[MAX_COTHREADS], _cothreads_raw[OBJ_COTHREAD * MAX_COTHREADS];
auto _current = 0;

yield()
{
    asm("int 0x80");
}

proc_exec(aout_seg)
{
    auto code_seg = aout_seg + 1;
    auto code_off = *aout_seg:10;
    auto data_seg = aout_seg + 1 + (*aout_seg:2 >> 4);
    auto data_off = *aout_seg:4 + *aout_seg:6;
    return cothread_new(code_seg, code_off, data_seg, data_off);
}

cothread_new(code_seg, code_off, data_seg, data_off)
{
    auto ptr;
    auto i, found = 0;
    for(i = 0; i < MAX_COTHREADS; i++)
    {
        ptr = _cothreads[i];
        if(ptr[COTHREAD_STACK_SEG] == 0)
        {
            found = 1;
            break;
        }
    }
    if(found == 0) return 0;
    asm
    (
        "cli",
        "mov si, ss",
        "mov [_new_sp], sp",
        "mov [_new_ss], si",
        "mov bx, [bp-2]",
        "mov cx, [bp+4]",
        "mov dx, [bp+6]",
        "mov si, [bp+8]",
        "mov sp, [bp+10]",
        "mov ss, si",
        "sti",
        "pushf",
        "push cx",
        "push dx",
        "push ax",
        "push ax",
        "push ax",
        "push ax",
        "push ax",
        "push ax",
        "push ax",
        "push ss",
        "push ss",
        "mov [bp+10], sp",
        "mov si, ss",
        "mov [bx+2], si",
        "mov [bx+4], sp",
        "cli",
        "mov sp, [_new_sp]",
        "mov si, [_new_ss]",
        "mov ss, si",
        "sti",
        "section .data",
        "_new_ss: dw 0",
        "_new_sp: dw 0",
        "section .text"
    );
    ptr[COTHREAD_NEXT] = _current[COTHREAD_NEXT];
    _current[COTHREAD_NEXT] = ptr;
    return ptr[COTHREAD_ID];
}

cothread_yield()
{
    asm
    (
        "push ax",
        "push bx",
        "push cx",
        "push dx",
        "push si",
        "push di",
        "push ds",
        "push es",
        "mov si, ss",
        "mov di, sp",
        "mov ax, cs",
        "add ax, __segoff",
        "mov ds, ax",
        "mov es, ax",
        "cli",
        "mov ss, ax",
        "mov sp, yield_stack_top",
        "sti",
        "mov bx, [__current]",
        "mov [bx+2], si",
        "mov [bx+4], di",
        "mov bx, [bx+6]",
        "mov [__current], bx",
        "mov si, [bx+2]",
        "mov di, [bx+4]",
        "cli",
        "mov ss, si",
        "mov sp, di",
        "sti",
        "pop es",
        "pop ds",
        "pop di",
        "pop si",
        "pop dx",
        "pop cx",
        "pop bx", 
        "pop ax",
        "pop bp",
        "iret",
        "section .data",
        "resb 1024",
        "yield_stack_top:",
        "section .text"
    );
}

cothread_init()
{
    auto i;
    for(i = 0; i < MAX_COTHREADS; i++)
    {
        _cothreads[i] = &_cothreads_raw[i * OBJ_COTHREAD];
        _cothreads[i][COTHREAD_ID] = i;
        _cothreads[i][COTHREAD_STACK_SEG] = 0;
        _cothreads[i][COTHREAD_STACK_OFF] = 0;
        _cothreads[i][COTHREAD_NEXT] = _cothreads[i];
    }
    _current = _cothreads[0];
    _current[COTHREAD_STACK_SEG] = mem_get_data_seg();
    *0x0000:(0x80 * 4) = &cothread_yield;
    *0x0000:(0x80 * 4 + 2) = mem_get_code_seg();
}